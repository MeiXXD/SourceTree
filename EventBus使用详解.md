##EventBus

###概述

>EventBus 是一款针对 Android 优化的发布/订阅事件总线。主要功能是替代 Intent，Handler，BroadCast 在Fragment，Activity，Service，线程之间传递消息。优点是开销小，代码更优雅。以及将发送者和接收者解耦。

###使用

* onEvent：如果使用 onEvent 作为订阅函数，那么该事件在哪个线程发布出来的，onEvent 就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在 onEvent 方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。

* onEventMainThread：如果使用 onEventMainThread 作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread 都会在 UI 线程中执行，接收事件就会在UI线程中运行，这个在 Android 中是非常有用的，因为在 Android 中只能在UI线程中跟新UI，所以在 onEvnetMainThread 方法中是不能执行耗时操作的。

* onEventBackground：如果使用 onEventBackgrond 作为订阅函数，那么如果事件是在 UI 线程中发布出来的，那么 onEventBackground 就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么 onEventBackground 函数直接在该子线程中执行。

* onEventAsync：使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync。

注：

>在 3.0 之前，EventBus 还没有使用注解方式。消息处理的方法也只能限定于 onEvent、onEventMainThread、onEventBackgroundThread 和 onEventAsync，分别代表四种线程模型。缺点：无法根据方法名推断方法的功能，易读性较差。

>而在 3.0 之后，消息处理的方法可以随便取名，但是需要添加一个注解 @Subscribe，并且要指定线程模型（默认为POSTING）。另外，事件处理函数的访问权限必须为 public，否则会报异常。

###EventBus 3.0

在 EventBus 中的观察者通常有四种线程模型，分别是POSTING（默认）、MAIN、BACKGROUND与ASYNC，分别对应之前版本的onEvent、onEventMainThread、onEventBackground、onEventAsync方法。

具体使用如下：

```java
@Subscribe(threadMode = ThreadMode.POSTING)
public void onMessageEventPostThread(MessageEvent messageEvent) {

}

@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessageEventMainThread(MessageEvent messageEvent) {

}

@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void onMessageEventBackgroundThread(MessageEvent messageEvent) {

}

@Subscribe(threadMode = ThreadMode.ASYNC)
public void onMessageEventAsync(MessageEvent messageEvent) {

}
```

###黏性事件

除了普通事件外，EventBus 还支持发送黏性事件。简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。

具体使用如下：

黏性事件处理函数：

```java
@Subscribe(sticky = true)
public void XXX(MessageEvent messageEvent) {
    ......
}
```

发送黏性事件：

```java
EventBus.getDefault().postSticky(new MessageEvent("test"));
```

注：
>粘性事件能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。

---

另外，还支持获取和删除粘性事件。

方法1：

```java
MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class); 

if(stickyEvent != null) {
    EventBus.getDefault().removeStickyEvent(stickyEvent);
}
```

方法2：

```java
MessageEvent stickyEvent = EventBus.getDefault().removeStickyEvent(MessageEvent.class);

if(stickyEvent != null) {
    
} 
```

###具体使用

注解使用：

```java
@Subscribe(threadMode = ThreadMode.POSTING, priority = 0, sticky = true)
```

注：
>0 表示最高优先级

---
不管 EventBus 版本是多少，都需要在混淆中去除 EventBus 相关类。

```java
-keep class org.greenrobot.eventbus.** {*;}
```

注：
>EventBus 3.0版本与之前版本的包名不同，所以在混淆时需要作相应的变动。

EventBus 3之前，需要在混淆文件中添加：

```java
#去除eventBus方法的混淆
-keepclassmembers class ** {
  public void onEvent*(**);
  void onEvent*(**);
}
```

EventBus 3，需要在混淆文件中添加：

```java
#去除注解的混淆：
-keepattributes *Annotation*

#去除 ThreadMode 枚举的混淆：
-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }

#去除被 Subscribe 注解标注的方法的混淆：
-keepclassmembers class * {
  @org.greenrobot.eventbus.Subscribe <methods>;
}

#去除 ThreadMode.ASYNC 的混淆：
-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {
  <init>(java.lang.Throwable);
}
```

###EventBus 3.0 索引使用

相比于之前使用反射进行方法注册的方式，直接使用注解，其实速度是要变慢的。但是，3.0 中添加了 EventBus processor，可以在编译时，生成索引类，这样，可以将eventbus的性能提升3到6倍。

具体使用过程中，gradle 2.2中已经引入了 annotationProcessor。所以不需要再像之前那样使用 apt，直接使用annotationProcessor 即可。

首先，在 app build.gradle 中添加 annotationProcessor 依赖：

```java
dependencies {
    ......
    annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1'
    ......
}
```

其次，在 app build.gradle 中配置 annotationProcessorOptions：

```java
defaultConfig {
    javaCompileOptions {
        annotationProcessorOptions {
            arguments = [eventBusIndex: "com.example.study.MyEventBusIndex"]
        }
    }
}
```

这样，首次编译后，会在 build\generated\source\apt\debug\ 目录下生成包名为 com.example.study 的索引类 MyEventBusIndex。具体如下：

```java
package com.example.study;

import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;
import org.greenrobot.eventbus.meta.SubscriberMethodInfo;
import org.greenrobot.eventbus.meta.SubscriberInfo;
import org.greenrobot.eventbus.meta.SubscriberInfoIndex;
import org.greenrobot.eventbus.ThreadMode;
import java.util.HashMap;
import java.util.Map;

/** This class is generated by EventBus, do not edit. */
public class CmbEventBusIndex implements SubscriberInfoIndex {
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;
    
    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();
        putIndex(new SimpleSubscriberInfo(事件处理类名, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("事件处理方法名",事件类名, 事件ThreadMode类型),
        }));
    }
    
    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }
    
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```

这样，就有了所有的 EventBus 事件索引类。然后将生成的类复制到定义的包名下。

因为 EventBus 默认使用单例模式，所以需要在项目最初当索引添加到 EventBus 对象中。一般在 application 中 的 OnCreate 中添加：

```java
EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();
```

可以看到，当添加了索引之后，需要先build一次，生成索引类。然后再编译生成apk。
注：
>在实际使用中，发现索引生成不全的问题。

>比如如 a 是 app 模块，b 是 library 模块，a 依赖 b。这样的情况下， 在 a 中使用 eventbus index 时，发现索引类中并没有包含 b 库中的 eventbus 事件函数。

###不同版本性能对比
![eventbus不同版本性能对比.png](https://ooo.0o0.ooo/2016/12/23/585cddc50409a.png)

使用索引后，性能大幅提升。
###我是坑

* 跨进程问题：目前 EventBus 只支持跨线程，而不支持跨进程。如果一个 app 的 service 起到了另一个进程中，那么注册监听的模块则会收不到另一个进程的 EventBus 发出的事件。跨进程考虑使用广播。

* 事件环路问题：在使用 EventBus 时，通常我们会把两个模块相互监听，来达到一个相互回调通信的目的。但这样一旦出现死循环，而且如果没有相应的日志信息，很难定位问题。所以在使用 EventBus 的模块，如果在回调上有环路，而且回调方法复杂到了一定程度的话，就要考虑把接收事件专门封装成一个子模块，同时考虑避免出现事件环路。



