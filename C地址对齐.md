笔试面试过程中，总是会遇到sizeof的考察，尤其常见的就是sizeof(结构体类型变量)的考察。今天就总结一下sizeof(结构体类型变量)的使用。

先看下面一个例子：

```c
struct A{     
	char c1;
	short s1;
	char c2;
	float f1;
	double d1;
};
```

那么，sizeof(a)应该等于多少呢（a姑且代表A类型的变量）？**答案是24。**你做对了吗？

---
下面详细讲一下C中的地址对齐。

为了提高CPU的存储速度，编译器对一些变量的起始地址做“对齐”处理。

>**在默认情况下，规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数**。

下面列出常用类型的对齐方式：
 * char   偏移量必须为sizeof(char)即1的倍数
 * short  偏移量必须为sizeof(short)即2的倍数
 * int    偏移量必须为sizeof(int)即4的倍数
 * long   偏移量必须为sizeof(int)即4的倍数
 * float  偏移量必须为sizeof(float)即4的倍数
 * double 偏移量必须为sizeof(double)即8的倍数

>**各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节编译器会自动填充。同时编译器为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。**

下面结合示例看一下上面的讲述：

```c
//注释中，从左到右分别代表偏移量、需补字节、字节数
struct A{
	char c1;    // 0  0  1
	short s1;   // 1  1  2
	char c2;    // 4  0  1
	float f1;   // 5  3  4
	double d1;  // 12 4  8
	            //合计20字节，不是边界(double类型8字节)的倍数，补上4字节，共24
};

struct B{
	char c1;    // 0  0  1
	char c2;    // 1  0  1
	short s1;   // 2  0  2
	float f1;   // 4  0  4
	double d1;  // 8  0  8
	            //合计16字节，是边界(double类型8字节)的倍数，补上0字节，共16
};
```

编译器对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也可以屏蔽掉变量默认的对齐方式，自己设定变量的对齐方式。

---
GCC中提供了**#pragma pack(n)**来设定变量以n字节对齐方式。

n字节对齐就是说变量存放的起始地址的偏移量有两种情况：
>1. **如果该变量所占用的字节数小于等于n，那么偏移量必须满足默认的对齐方式；**
2. **如果该变量的类型所占用的字节数大于n，那么偏移量为n的倍数，不用满足默认的对齐方式。**

结构的总大小也有个约束条件:
>**如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。**

例1：

```c
#pragma pack(4)   //设定为4字节对齐

struct A{
  char m1;        //小于4，采用默认，1个字节
  double m4;      //大于4，则偏移量必须是n的倍数，补3个字节，再放m4
  int m3;         //等于4，采用默认，4个字节
                  //总大小应为n的倍数，是16个字节
};
pragma pack()     //恢复对齐状态
```

例2：

```c
#pragma pack(8)   //设定为8字节对齐

struct s1{
  short a;        //小于8，采用默认，2个字节
  long b;         //小于8，采用默认，补2个字节，再放b
                  //一共8个字节，已是n的倍数
};

struct s2{
  char c;         //小于8，采用默认，1个字节
  s1 d;           //等于8，采用默认，补7个字节，再放s1
  long long e;    //小于8，采用默认，4个字节
                  //一共20个字节，不是n的倍数，所以应补4个字节，最后为24个字节
};

#pragma pack()    //恢复对齐状态
```

###总结
sizeof(结构体类型变量)有默认和自己设定对齐两种对齐方式：

默认情况下，各成员变量存放的起始地址必须为自身所占空间数的倍数，最后整个结构体的大小必须为结构体中占用空间最大的成员变量占用的空间数的整数倍。

自己设定对齐的情况下，成员变量所占空间数小于等于n的时候，采用默认对齐方式；大于n的时候，偏移量需为n的整数倍。最后整个结构体的大小，如果n大于了结构体中各个成员变量所占的空间数，则结构体的大小需是占用空间最大的成员变量所占空间数的整数倍；否则结构体大小需是n的整数倍。